<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="generator" content="Doxygen 1.8.13"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>PDI: Specification tree Reference</title>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<script type="text/javascript" src="navtreedata.js"></script>
	<script type="text/javascript" src="navtree.js"></script>
	<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div>
<header id="titlearea">
	<div id="projectlogo"><a href="index.html"><img alt="Logo" src="logo.png"/></a></div>
	<h1 id="projectname">PDI&nbsp;<span id="projectnumber">0.7.0-pre_date-2020-11-25-11_33</span></h1>
	<h2 id="projectbrief">Data exchange made easy</h2>
</header>
<nav id="tabs"><ul>
	<li><a href="index.html">About</a>
	<li><a href="Installation.html">Installation</a>
	<li><a href="Concepts.html">Core concepts</a>
	<li><a href="First_steps.html">First steps</a>
	<li><a href="Hands_on.html">Tutorial</a>
	<li><a href="PDI_example.html">PDI example</a>
	<li><a href="modules.html">C API reference</a>
	<li><a href="Specification_tree_ref.html">Specification tree reference</a>
	<li><a href="Plugins.html">Plugins</a>
	<li id="gitlab-ribbon"><a href="https://gitlab.maisondelasimulation.fr/pdidev/pdi">Contribute on Gitlab</a></li>
</ul></nav>
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('Specification_tree_ref.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Specification tree Reference </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The PDI specification tree is expressed in <a href="https://en.wikipedia.org/wiki/YAML">YAML</a>. As such, it is a tree that contains 3 distinct kinds of nodes:</p><ul>
<li>scalars,</li>
<li>sequences,</li>
<li>mappings.</li>
</ul>
<p>A <b>scalar</b> is a leaf in the tree, represented as a string. Some form of scalars can be interpreted as a boolean, integer or floating-point valued. Simple examples of scalars include for example (see the <a href="https://yaml.org/spec/1.2/spec.html#id2760844">YAML specification</a> for the complete syntax):</p><ul>
<li><code>"hello"</code>,</li>
<li><code>world</code>,</li>
<li><code>3</code>,</li>
<li><code>5.7</code>.</li>
</ul>
<p>A <b>sequence</b> is an ordered list of sub-nodes (that can themselves be scalars, sequences or mappings). Two main syntaxes are available for sequences (see the <a href="https://yaml.org/spec/1.2/spec.html#id2759963">YAML specification</a> for the complete syntax).</p><ul>
<li>in-line sequence: <code>[1, 2, 3, hello, "world"]</code></li>
<li>multi-line sequence: <div class="fragment"><div class="line">- 1</div><div class="line">- 2</div><div class="line">- 3</div><div class="line">- hello</div><div class="line">- world</div></div><!-- fragment --></li>
</ul>
<p>A <b>mapping</b> is an unordered list of key-value pairs (whose elements can themselves be scalars, sequences or mappings). Two main syntaxes are available for mapping (see the <a href="https://yaml.org/spec/1.2/spec.html#id2759963">YAML specification</a> for the complete syntax).</p><ul>
<li>in-line mapping: <code>{1: one, 2: "two", "three": 3}</code></li>
<li>multi-line mapping: <div class="fragment"><div class="line">1: one</div><div class="line">2: two</div><div class="line">&quot;three&quot;: 3</div></div><!-- fragment --></li>
</ul>
<h1><a class="anchor" id="root_node"></a>
specification tree root</h1>
<p>The <em>specification tree root</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"data"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#data_map_node">data_map</a> </td></tr>
<tr>
<td align="left"><code>"metadata"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#data_map_node">data_map</a> </td></tr>
<tr>
<td align="left"><code>"plugins"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#plugin_map_node">plugin_map</a> </td></tr>
<tr>
<td align="left"><code>"plugin_path"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#plugin_path_map_node">plugin_path</a> </td></tr>
<tr>
<td align="left"><code>".*"</code> (<em>optional</em>)</td><td align="left"><em>anything</em> </td></tr>
</table>
<ul>
<li>the <code>data</code> and <code>metadata</code> sections specify the type of the data in buffers exposed by the application; for <code>metadata</code>, PDI keeps a copy while it only keeps references for <code>data</code>,</li>
<li>the <code>plugin</code> section specifies the list of plugins to load and their configuration,</li>
<li>additional sections are ignored.</li>
</ul>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">metadata:</div><div class="line">  my_metadata: int</div><div class="line">data:</div><div class="line">  my_data:</div><div class="line">    type: array</div><div class="line">    subtype: double</div><div class="line">    size: 5</div><div class="line">plugins:</div><div class="line">  decl_hdf5: #...</div><div class="line">  mpi: #...</div></div><!-- fragment --><h1><a class="anchor" id="array_type_node"></a>
array_type</h1>
<p>A <em>array_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"array"</code> </td></tr>
<tr>
<td align="left"><code>"size"</code></td><td align="left">a <a class="el" href="Specification_tree_ref.html#intexpr_or_seq_node">intexpr_or_seq</a> </td></tr>
<tr>
<td align="left"><code>"subtype"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#datatype_node">datatype</a> </td></tr>
<tr>
<td align="left"><code>"subsize"</code> (<em>optional, deprecated</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#intexpr_or_seq_node">intexpr_or_seq</a> </td></tr>
<tr>
<td align="left"><code>"start"</code> (<em>optional, deprecated</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#intexpr_or_seq_node">intexpr_or_seq</a> </td></tr>
</table>
<p>A <em>array_type_node</em> represents a potentially multi-dimensional array where:</p><ul>
<li>the value associated to the <code>size</code> key represents the size of the array in each dimension (C order),</li>
<li>the value associated to the <code>subtype</code> key represents the type of the elements in the array,</li>
<li>the value associated to the <code>subsize</code> key represents the number of elements to actually use in each dimension (slicing), if specified it <b>must</b> have the same number of elements as <code>size</code>, this defaults to the full array size in each dimension,</li>
<li>the value associated to the <code>start</code> key represents the index of the first element to actually use in each dimension (slicing), if specified it <b>must</b> have the same number of elements as <code>size</code>, this defaults to the first (0) element in each dimension.</li>
</ul>
<p><b>Examples:</b></p>
<div class="fragment"><div class="line">type: array</div><div class="line">subtype: double</div><div class="line">size: 5</div></div><!-- fragment --><div class="fragment"><div class="line">type: array</div><div class="line">subtype: { type: character, kind: 4 }</div><div class="line">size: [ &#39;$size_1d&#39;, &#39;$size_2d&#39; ]</div></div><!-- fragment --><h1><a class="anchor" id="char_type_node"></a>
char_type</h1>
<p>A <em>char_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"char"</code> </td></tr>
</table>
<p>A <em>char_type</em> represents the C <code>char</code> datatype; it accepts no parameter.</p>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">type: char</div></div><!-- fragment --><h1><a class="anchor" id="character_type_node"></a>
character_type</h1>
<p>A <em>character_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"character"</code> </td></tr>
<tr>
<td align="left"><code>"kind"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#expression_node">integer-valued $-expression</a> </td></tr>
</table>
<p>A <em>character_type_node</em> represents the Fortran <code>character</code> datatype. The value associated to the <code>kind</code> key corresponds to the Fortran <em>kind</em> parameter (<code>character(kind=...)</code>).</p>
<p><b>Examples:</b></p>
<div class="fragment"><div class="line">type: character</div></div><!-- fragment --><div class="fragment"><div class="line">type: character</div><div class="line">kind: 4</div></div><!-- fragment --><h1><a class="anchor" id="datatype_node"></a>
datatype</h1>
<p>A <em>datatype</em> can be <b>any of</b>:</p><ul>
<li>a <a class="el" href="Specification_tree_ref.html#array_type_node">array_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#char_type_node">char_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#character_type_node">character_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#double_type_node">double_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#float_type_node">float_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#int_type_node">int_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#int16_type_node">int16_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#int32_type_node">int32_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#int64_type_node">int64_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#int8_type_node">int8_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#integer_type_node">integer_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#logical_type_node">logical_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#real_type_node">real_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#record_type_node">record_type</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#simple_datatype_node">simple_datatype</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#struct_type_node">struct_type</a>.</li>
</ul>
<p>Amongst these, <a class="el" href="Specification_tree_ref.html#simple_datatype_node">simple_datatype</a> is the only scalar. All others are dictionaries with a <code>type</code> key used for disambiguation between them. Plugins can add new options that follow the same pattern.</p>
<p>A <em>datatype</em> represents the memory layout and interpretation for data exposed by the user in the <a class="el" href="Concepts.html#Data_store">data store</a>.</p>
<h1><a class="anchor" id="data_map_node"></a>
data_map</h1>
<p>A <em>data_map</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>".*"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#datatype_node">datatype</a> </td></tr>
</table>
<ul>
<li>each key identifies the name of a buffer exposed to PDI associated to its type.</li>
</ul>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">my_data_1: int</div><div class="line">my_data_2: {type: array, subtype: double, size: 5}</div></div><!-- fragment --><h1><a class="anchor" id="double_type_node"></a>
double_type</h1>
<p>A <em>double_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"double"</code> </td></tr>
</table>
<p>A <em>double_type</em> represents the C <code>double</code> type. It accepts no parameter.</p>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">type: double</div></div><!-- fragment --><h1><a class="anchor" id="expression_node"></a>
$-expression</h1>
<p>A <em>$-expression</em> is a <b>scalar</b> whose content matches the following grammar:</p>
<div class="fragment"><div class="line"><span class="comment">/* parsing as a REFERENCE is preferred over OPERATION</span></div><div class="line"><span class="comment">   parsing as an OPERATION is preferred over STRING_LITERAL</span></div><div class="line"><span class="comment">*/</span></div><div class="line">EXPRESSION     := REFERENCE | OPERATION | STRING_LITERAL</div><div class="line"></div><div class="line">STRING_LITERAL := ( CHAR | <span class="charliteral">&#39;\&#39;</span> <span class="charliteral">&#39;\&#39;</span> | <span class="charliteral">&#39;\&#39;</span> <span class="charliteral">&#39;$&#39;</span></div><div class="line">                  | REFERENCE</div><div class="line">                  | <span class="charliteral">&#39;$&#39;</span> <span class="charliteral">&#39;(&#39;</span> OPERATION <span class="charliteral">&#39;)&#39;</span></div><div class="line">                  )*</div><div class="line"></div><div class="line"><span class="comment">/* The operator descending precedence order is:</span></div><div class="line"><span class="comment">   1. *, /, %: multiplication, division and modulo,</span></div><div class="line"><span class="comment">   2. +, -: addition and subtraction,</span></div><div class="line"><span class="comment">   3. &lt;, &gt;: less than and greater than,</span></div><div class="line"><span class="comment">   4. =: equality,</span></div><div class="line"><span class="comment">   5. &amp;: logical AND,</span></div><div class="line"><span class="comment">   6. |: logical OR.</span></div><div class="line"><span class="comment">*/</span></div><div class="line">OPERATION      := TERM ( OPERATOR TERM )*</div><div class="line"></div><div class="line">TERM           := ( INT_LITERAL | REFERENCE | <span class="charliteral">&#39;(&#39;</span> OPERATION <span class="charliteral">&#39;)&#39;</span> )</div><div class="line"></div><div class="line">REFERENCE      := <span class="charliteral">&#39;$&#39;</span> ( IREFERENCE | <span class="charliteral">&#39;{&#39;</span> IREFERENCE <span class="charliteral">&#39;}&#39;</span> )</div><div class="line"></div><div class="line">IREFERENCE     := ID ( <span class="charliteral">&#39;[&#39;</span> OPERATION <span class="charliteral">&#39;]&#39;</span> )*</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">INT_LITERAL ~= (0x)? [0-9]+ ( \.  )</div><div class="line">ID          ~= [a-zA-Z_][a-zA-Z0-9_]*</div><div class="line">CHAR        ~= [^$\\]</div><div class="line">OPERATOR    ~= [|&amp;=&lt;&gt;+\-\*/%]</div></div><!-- fragment --><p>The rules for evaluating an expression are close to those of BASH for example.</p>
<p>In addition to raw text, a <code>STRING_LITERAL</code> can contain references to the string value of some data in the store as well as the result of an operation by enclosing it inside a dollar-parenthesis <code>$()</code>.</p>
<p>An <code>OPERATION</code> can include logical and arithmetic operators grouped by parenthesis. The basic terms manipulated in an operation can be integer literals or references to the integer value of some data in the store.</p>
<p>A <code>REFERENCE</code> is introduced by a dollar <code>$</code> sign and optionally enclosed in curly braces <code>{</code>, <code>}</code>. Its value is that of the data or metadata with the associated name. It is always a good idea to have referenced values in the metadata section as it prevents dangling references. A direct reference is possible as well as sub-references to array elements using the square brackets <code>[</code>, <code>]</code> operator.</p>
<p>The value-type of an <code>EXPRESSION</code> is as follow:</p><ul>
<li>if it's a <code>REFERENCE</code>, it has the type of the referenced data in the store,</li>
<li>if it's a <code>OPERATION</code>, it is integer-valued,</li>
<li>if it's a <code>STRING_LITERAL</code>, it is string-valued.</li>
</ul>
<p>In addition, an integer can be interpreted as a string or as a boolean value where zero is interpreted as false and any other value as true.</p>
<p><b>Examples:</b></p>
<div class="fragment"><div class="line">&#39;$my_data&#39;</div></div><!-- fragment --><div class="fragment"><div class="line">&#39;($my_data + 3) % 6&#39;</div></div><!-- fragment --><div class="fragment"><div class="line">&#39;my name is ${my_name}&#39;</div></div><!-- fragment --><h1><a class="anchor" id="float_type_node"></a>
float_type</h1>
<p>A <em>float_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"float"</code> </td></tr>
</table>
<p>A <a class="el" href="Specification_tree_ref.html#float_type_node">float_type</a> represents the C <code>float</code> type. It accepts no parameter.</p>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">type: float</div></div><!-- fragment --><h1><a class="anchor" id="int_type_node"></a>
int_type</h1>
<p>A <em>int_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"int"</code> </td></tr>
</table>
<p>A <a class="el" href="Specification_tree_ref.html#int_type_node">int_type</a> represents the C <code>int</code> type. It accepts no parameter.</p>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">type: int</div></div><!-- fragment --><h1><a class="anchor" id="int16_type_node"></a>
int16_type</h1>
<p>A <em>int16_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"int16"</code> </td></tr>
</table>
<p>A <a class="el" href="Specification_tree_ref.html#int16_type_node">int16_type</a> represents the C <code>int16_t</code> type from the <code>&lt;stdtypes.h&gt;</code> header. It accepts no parameter.</p>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">type: int16</div></div><!-- fragment --><h1><a class="anchor" id="int32_type_node"></a>
int32_type</h1>
<p>A <em>int32_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"int32"</code> </td></tr>
</table>
<p>A <a class="el" href="Specification_tree_ref.html#int32_type_node">int32_type</a> represents the C <code>int32_t</code> type from the <code>&lt;stdtypes.h&gt;</code> header. It accepts no parameter.</p>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">type: int32</div></div><!-- fragment --><h1><a class="anchor" id="int64_type_node"></a>
int64_type</h1>
<p>A <em>int64_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"int64"</code> </td></tr>
</table>
<p>A <em>int64_type</em> represents the C <code>int64_t</code> type from the <code>&lt;stdtypes.h&gt;</code> header. It accepts no parameter.</p>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">type: int64</div></div><!-- fragment --><h1><a class="anchor" id="int8_type_node"></a>
int8_type</h1>
<p>A <em>int8_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"int8"</code> </td></tr>
</table>
<p>A <a class="el" href="Specification_tree_ref.html#int8_type_node">int8_type</a> represents the C <code>int8_t</code> type from the <code>&lt;stdtypes.h&gt;</code> header. It accepts no parameter.</p>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">type: int8</div></div><!-- fragment --><h1><a class="anchor" id="integer_type_node"></a>
integer_type</h1>
<p>A <em>integer_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"integer"</code> </td></tr>
<tr>
<td align="left"><code>"kind"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#expression_node">integer-valued $-expression</a> </td></tr>
</table>
<p>A <em>integer_type</em> represents the Fortran <code>integer</code> datatype. The value associated to the <code>kind</code> key corresponds to the Fortran <em>kind</em> parameter (<code>integer(kind=...)</code>). If missing, the default kind of the Fortran implementation is used.</p>
<p><b>Examples:</b></p>
<div class="fragment"><div class="line">type: integer</div></div><!-- fragment --><div class="fragment"><div class="line">type: integer</div><div class="line">kind: 2</div></div><!-- fragment --><h1><a class="anchor" id="intexpr_seq_node"></a>
intexpr_seq</h1>
<p>A <em>intexpr_seq</em> is a <b>sequence</b> where each element of the sequence is a <a class="el" href="Specification_tree_ref.html#expression_node">integer-valued $-expression</a>.</p>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">[ 1, &#39;2&#39;, &#39;$size&#39;, &#39;$other_size + 2&#39; ]</div></div><!-- fragment --><h1><a class="anchor" id="intexpr_or_seq_node"></a>
intexpr_or_seq</h1>
<p>A <em>intexpr_or_seq</em> can be <b>any of</b>:</p><ul>
<li>a <a class="el" href="Specification_tree_ref.html#expression_node">integer-valued $-expression</a>,</li>
<li>a <a class="el" href="Specification_tree_ref.html#intexpr_seq_node">intexpr_seq</a>.</li>
</ul>
<p>In that context, a simple <a class="el" href="Specification_tree_ref.html#expression_node">$-expression</a> is interpreted as a shortcut for a sequence containing a single <a class="el" href="Specification_tree_ref.html#expression_node">$-expression</a>.</p>
<p>For example, the following value: </p><div class="fragment"><div class="line">&quot;$x + 2&quot;</div></div><!-- fragment --><p>is interpreted as if it was: </p><div class="fragment"><div class="line">[ &quot;$x + 2&quot; ]</div></div><!-- fragment --><h1><a class="anchor" id="logical_type_node"></a>
logical_type</h1>
<p>A <em>logical_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"logical"</code> </td></tr>
<tr>
<td align="left"><code>"kind"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#expression_node">integer-valued $-expression</a> </td></tr>
</table>
<p>A <em>logical_type</em> represents the Fortran <code>logical</code> datatype. The value associated to the <code>kind</code> key corresponds to the Fortran <em>kind</em> parameter (<code>logical(kind=...)</code>). If missing, the default kind of the Fortran implementation is used.</p>
<p><b>Examples:</b></p>
<div class="fragment"><div class="line">type: logical</div></div><!-- fragment --><div class="fragment"><div class="line">type: logical</div><div class="line">kind: 1</div></div><!-- fragment --><h1><a class="anchor" id="struct_member_desc_node"></a>
struct_member_desc</h1>
<p>A <em>struct_member_desc</em> is a <b>mapping</b> that contains the following keys: </p><table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left">a <code>scalar</code>, <code>array</code>, <code>record</code> or <code>struct</code> </td></tr>
<tr>
<td align="left"><code>".*"</code> (<em>optional</em>)</td><td align="left"><em>anything</em> </td></tr>
</table>
<ul>
<li>the value associated to the <code>type</code> key identifies the <a class="el" href="Specification_tree_ref.html#datatype_node">type</a> of this member, all other keys required for this <a class="el" href="Specification_tree_ref.html#datatype_node">datatype</a> must be present.</li>
</ul>
<p><b>Examples:</b></p>
<div class="fragment"><div class="line">type: struct</div><div class="line">members:</div><div class="line">  my_char: char</div></div><!-- fragment --><div class="fragment"><div class="line">type: struct</div><div class="line">members:</div><div class="line">  my_long: int64</div><div class="line">  my_array:</div><div class="line">    type: array</div><div class="line">    subtype: int64</div><div class="line">    size: [10, 10]</div></div><!-- fragment --><p>See <a class="el" href="Specification_tree_ref.html#struct_type_node">struct_type</a> for more examples.</p>
<h1><a class="anchor" id="record_member_desc_node"></a>
record_member_desc</h1>
<p>A <em>record_member_desc</em> is a <b>mapping</b> that contains the following keys: </p><table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"disp"</code></td><td align="left">a <a class="el" href="Specification_tree_ref.html#expression_node">integer-valued $-expression</a> </td></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left">a <code>scalar</code>, <code>array</code>, <code>record</code> or <code>struct</code> </td></tr>
<tr>
<td align="left"><code>".*"</code> (<em>optional</em>)</td><td align="left"><em>anything</em> </td></tr>
</table>
<ul>
<li>the value associated to the <code>disp</code> key identifies the displacement in bytes from the base address of the record and the address of this specific member,</li>
<li>the value associated to the <code>type</code> key identifies the <a class="el" href="Specification_tree_ref.html#datatype_node">type</a> of this record, all other keys required for this <a class="el" href="Specification_tree_ref.html#datatype_node">datatype</a> must be present.</li>
</ul>
<p><b>Examples:</b></p>
<div class="fragment"><div class="line">type: record</div><div class="line">buffersize: 1</div><div class="line">members:</div><div class="line">  my_char:</div><div class="line">        disp: 0</div><div class="line">        type: char</div></div><!-- fragment --><div class="fragment"><div class="line">type: record</div><div class="line">buffersize: 808 </div><div class="line">members:</div><div class="line">  my_long:</div><div class="line">    disp: 0</div><div class="line">    type: int64</div><div class="line">  my_array:</div><div class="line">    disp: 8</div><div class="line">    type: array</div><div class="line">    subtype: int64</div><div class="line">    size: [10, 10]</div></div><!-- fragment --><p>See <a class="el" href="Specification_tree_ref.html#record_type_node">record_type</a> for more examples.</p>
<h1><a class="anchor" id="struct_members_map_node"></a>
struct_members_map</h1>
<p>A <em>struct_members_map</em> is a <b>mapping</b> that contains the following keys: </p><table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>".*"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#struct_member_desc_node">struct_member_desc</a> </td></tr>
</table>
<ul>
<li>each key identifies the name of a member of the struct and the value associated to it describes the member itself.</li>
</ul>
<p>See <a class="el" href="Specification_tree_ref.html#struct_type_node">struct_type</a> for an example.</p>
<h1><a class="anchor" id="record_members_map_node"></a>
record_members_map</h1>
<p>A <em>record_members_map</em> is a <b>mapping</b> that contains the following keys: </p><table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>".*"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#record_member_desc_node">record_member_desc</a> </td></tr>
</table>
<ul>
<li>each key identifies the name of a member of the record and the value associated to it describes the member itself.</li>
</ul>
<p>See <a class="el" href="Specification_tree_ref.html#record_type_node">record_type</a> for an example.</p>
<h1><a class="anchor" id="plugin_map_node"></a>
plugin_map</h1>
<p>A <em>plugin_map</em> is a <b>mapping</b> that contains the following keys: </p><table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>".*"</code> (<em>optional</em>)</td><td align="left"><em>anything</em> </td></tr>
</table>
<ul>
<li>each key identifies the name of a plugin to load associated to its configuration; the content of the configuration depends on the plugin.</li>
</ul>
<p>Have a look at the <a class="el" href="Plugins.html">plugins</a> documentation to see the specification tree they accept.</p>
<p>See <a class="el" href="Specification_tree_ref.html#root_node">specification tree root</a> for an example.</p>
<h1><a class="anchor" id="real_type_node"></a>
real_type</h1>
<p>A <em>real_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"real"</code> </td></tr>
<tr>
<td align="left"><code>"kind"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#expression_node">integer-valued $-expression</a> </td></tr>
</table>
<p>A <em>real_type</em> represents the Fortran <code>real</code> datatype. The value associated to the <code>kind</code> key corresponds to the Fortran <em>kind</em> parameter (<code>real(kind=...)</code>). If missing, the default kind of the Fortran implementation is used.</p>
<p><b>Examples:</b></p>
<div class="fragment"><div class="line">type: real</div></div><!-- fragment --><div class="fragment"><div class="line">type: real</div><div class="line">kind: 8</div></div><!-- fragment --><h1><a class="anchor" id="struct_type_node"></a>
struct_type</h1>
<p>A <em>struct_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"struct"</code> </td></tr>
<tr>
<td align="left"><code>"members"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#struct_members_map_node">struct_members_map</a> </td></tr>
</table>
<p>A <a class="el" href="Specification_tree_ref.html#struct_type_node">struct_type</a> represents a "struct", <em>aka</em> C "struct", C++ "class". Buffersize and members displacemnts will be calculated by the PDI.</p>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">type: struct</div><div class="line">members:</div><div class="line">  first_int: int32</div><div class="line">  seconf_int: int32</div></div><!-- fragment --><h1><a class="anchor" id="record_type_node"></a>
record_type</h1>
<p>A <em>record_type</em> is a <b>mapping</b> that contains the following keys:</p>
<table class="doxtable">
<tr>
<th align="left">key</th><th align="left">value  </th></tr>
<tr>
<td align="left"><code>"type"</code></td><td align="left"><code>"record"</code> </td></tr>
<tr>
<td align="left"><code>"buffersize"</code></td><td align="left">a <a class="el" href="Specification_tree_ref.html#expression_node">integer-valued $-expression</a> </td></tr>
<tr>
<td align="left"><code>"members"</code> (<em>optional</em>)</td><td align="left">a <a class="el" href="Specification_tree_ref.html#record_members_map_node">record_members_map</a> </td></tr>
</table>
<p>A <a class="el" href="Specification_tree_ref.html#record_type_node">record_type</a> represents a "record" where:</p><ul>
<li>the value associated to the <code>buffersize</code> key represents the overall size of the record, including potential padding,</li>
<li>the value associated to the <code>members</code> key lists all members of the record with given displacements.</li>
</ul>
<p><b>Example:</b></p>
<div class="fragment"><div class="line">type: record</div><div class="line">buffersize: 8</div><div class="line">members:</div><div class="line">  first_int:</div><div class="line">    disp: 0</div><div class="line">    type: int32</div><div class="line">  seconf_int:</div><div class="line">    disp: 4</div><div class="line">    type: int32</div></div><!-- fragment --><h1><a class="anchor" id="simple_datatype_node"></a>
simple_datatype</h1>
<p>A <em>simple_datatype</em> is a <b>scalar</b>.</p>
<p>It is interpreted as a shortcut for a mapping with a single key <code>type</code> whose value is the provided scalar and therefore another <a class="el" href="Specification_tree_ref.html#datatype_node">datatype</a>.</p>
<p>For example, the following value: </p><div class="fragment"><div class="line">&quot;my_type&quot;</div></div><!-- fragment --><p>is interpreted as if it was: </p><div class="fragment"><div class="line">{ type: &quot;my_type&quot; }</div></div><!-- fragment --><h1><a class="anchor" id="plugin_path_map_node"></a>
plugin_path</h1>
<p>A path to directory where PDI should search for plugins. It can be single path:</p>
<div class="fragment"><div class="line">plugin_path: &quot;/home/user123/plugins&quot;</div></div><!-- fragment --><p>or array of paths (PDI will take first match):</p>
<div class="fragment"><div class="line">plugin_path: [&quot;/home/user123/plugins&quot;, &quot;/usr/lib/pdi/plugins&quot;]</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
</body>
</html>
