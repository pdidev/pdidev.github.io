<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="generator" content="Doxygen 1.8.13"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>PDI: How to create a plugin</title>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<script type="text/javascript" src="navtreedata.js"></script>
	<script type="text/javascript" src="navtree.js"></script>
	<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div>
<header id="titlearea">
	<div id="projectlogo"><a href="index.html"><img alt="Logo" src="logo.png"/></a></div>
	<h1 id="projectname">PDI&nbsp;<span id="projectnumber">0.7.0-pre_date-2020-05-28-12_15</span></h1>
	<h2 id="projectbrief">Data exchange made easy</h2>
</header>
<nav id="tabs"><ul>
	<li><a href="index.html">About</a>
	<li><a href="Concepts.html">Core concepts</a>
	<li><a href="Installation.html">Installation</a>
	<li><a href="First_steps.html">First steps</a>
	<li><a href="PDI_example.html">PDI example</a>
	<li><a href="Hands_on.html">Hands-on</a>
	<li><a href="Plugins.html">Plugins</a>
	<li><a href="modules.html">C API reference</a>
	<li><a href="Specification_tree_ref.html">Specification tree reference</a>
	<li id="gitlab-ribbon"><a href="https://gitlab.maisondelasimulation.fr/pdidev/pdi">Contribute on Gitlab</a></li>
</ul></nav>
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('how_to_create_plugin.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">How to create a plugin </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="plugin_class"></a>
Plugin class</h1>
<p>Plugin is a class, that handles shared data and triggered events to perform an I/O operations. It is dynamically linked to the user program by <a class="el" href="namespacePDI.html">PDI</a>. Behavior of each plugin is defined by specification tree in plugins subtree.</p>
<div class="fragment"><div class="line">plugins:</div><div class="line">  example:</div><div class="line">    ...</div></div><!-- fragment --><p> The given example will load example plugin and pass its subtree to the plugin's constructor.</p>
<p>The plugin has to inherit from <a class="el" href="classPDI_1_1Plugin.html" title="The class PDI plugins should implement. ">PDI::Plugin</a> and have a constructor with arguments <a class="el" href="classPDI_1_1Context.html">PDI::Context</a>&amp; and PC_tree_t.</p>
<h2><a class="anchor" id="example_plugin"></a>
Example plugin</h2>
<p>Example of the simplest plugin, that does nothing:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;pdi/context.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/paraconf_wrapper.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/plugin.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>example_plugin : <span class="keyword">public</span> <a class="code" href="classPDI_1_1Plugin.html">PDI::Plugin</a></div><div class="line">{</div><div class="line">    example_plugin(<a class="code" href="classPDI_1_1Context.html">PDI::Context</a>&amp; ctx, PC_tree_t spec_tree):</div><div class="line">        Plugin{ctx}</div><div class="line">    {}</div><div class="line">}</div><div class="line"></div><div class="line">PDI_PLUGIN(example)</div></div><!-- fragment --><h2><a class="anchor" id="adding_callback"></a>
Adding a callback</h2>
<p><a class="el" href="classPDI_1_1Context.html">PDI::Context</a> has a container with all the functions (callbacks) that are called when user is sharing the data (calls PDI_share). To add a new function to this container the plugin must call add_data_callback.</p>
<div class="fragment"><div class="line">std::function&lt;void()&gt; add_data_callback(<span class="keyword">const</span> std::function&lt;<span class="keywordtype">void</span>(<span class="keyword">const</span> std::string&amp;, Ref)&gt;&amp; callback, <span class="keyword">const</span> std::string&amp; name = {}))</div></div><!-- fragment --><p>The first argument is the function to be called when user shares the data. If the second parameter (name) is given, the function will be called only on a specified data name. Returns a function that removes the callback from <a class="el" href="classPDI_1_1Context.html">PDI::Context</a> container.</p>
<p>Example of adding new callback: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;pdi/context.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/paraconf_wrapper.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/plugin.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/ref_any.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>example_plugin : <span class="keyword">public</span> <a class="code" href="classPDI_1_1Plugin.html">PDI::Plugin</a></div><div class="line">{</div><div class="line">    example_plugin(<a class="code" href="classPDI_1_1Context.html">PDI::Context</a>&amp; ctx, PC_tree_t spec_tree):</div><div class="line">        Plugin{ctx}</div><div class="line">    {</div><div class="line">        ctx.<a class="code" href="classPDI_1_1Context.html#ac665503fccb2a848e7e85d5b2aa49ed5">add_data_callback</a>([](<span class="keyword">const</span> std::string&amp; data_name, <a class="code" href="classPDI_1_1Ref__any.html">PDI::Ref</a> ref){</div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;User has shared a data named &quot;</span> &lt;&lt; data_name &lt;&lt; std::endl;</div><div class="line">        });</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">PDI_PLUGIN(example)</div></div><!-- fragment --><p> If user create specification tree: </p><div class="fragment"><div class="line">data:</div><div class="line">    some_integer: int</div><div class="line"></div><div class="line">plugins:</div><div class="line">    example: ~</div></div><!-- fragment --><p> And a program: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;pdi.h&gt;</span></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main()</div><div class="line">{</div><div class="line">    <a class="code" href="group__init__final.html#ga3dc660be40c93c169337e3d2692b2ed0">PDI_init</a>(PC_parse_path(<span class="stringliteral">&quot;spec_tree.yaml&quot;</span>));</div><div class="line">    <span class="keywordtype">int</span> some_integer = 0;</div><div class="line">    <a class="code" href="group__hl__annotation.html#gabf3f81774644eff9a3cf511e57273454">PDI_expose</a>(<span class="stringliteral">&quot;some_integer&quot;</span>, &amp;some_integer, <a class="code" href="group__annotation.html#gga7c857647f7a8077648c28db634eeb805a49ed5399cbc2fca8085867ea04d01b6e">PDI_OUT</a>);</div><div class="line">    <a class="code" href="group__init__final.html#ga7995fbda2099950ed4ffc7fd4c0bb969">PDI_finalize</a>();</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><p> The console will display: </p><div class="fragment"><div class="line">[PDI][13:42:41] *** info: Initialization successful</div><div class="line">User has shared a data named some_integer</div><div class="line">[PDI][13:42:42] *** info: Finalization</div></div><!-- fragment --><h2><a class="anchor" id="rw_data"></a>
Reading and writing data</h2>
<p>Example of reading and writing data: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;pdi/context.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/paraconf_wrapper.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/plugin.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/ref_any.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>example_plugin : <span class="keyword">public</span> <a class="code" href="classPDI_1_1Plugin.html">PDI::Plugin</a></div><div class="line">{</div><div class="line">    example_plugin(<a class="code" href="classPDI_1_1Context.html">PDI::Context</a>&amp; ctx, PC_tree_t spec_tree):</div><div class="line">        Plugin{ctx}</div><div class="line">    {</div><div class="line">        ctx.<a class="code" href="classPDI_1_1Context.html#ac665503fccb2a848e7e85d5b2aa49ed5">add_data_callback</a>([](<span class="keyword">const</span> std::string&amp; data_name, <a class="code" href="classPDI_1_1Ref__any.html">PDI::Ref</a> ref){</div><div class="line">            <span class="keywordflow">if</span>(<a class="code" href="classPDI_1_1Ref__any.html">PDI::Ref_rw</a> ref_rw{ref}) {</div><div class="line">                <span class="comment">//Plugin can read and write</span></div><div class="line">                <span class="keywordtype">int</span>* some_integer = ref_rw.get();</div><div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="classPDI_1_1Ref__any.html">PDI::Ref_r</a> ref_r{ref}) {</div><div class="line">                <span class="comment">//Plugin can read</span></div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">int</span>* some_integer = ref_r.get();</div><div class="line">            } <span class="keywordflow">else</span> <span class="keywordflow">if</span>(<a class="code" href="classPDI_1_1Ref__any.html">PDI::Ref_w</a> ref_w{ref}) {</div><div class="line">                <span class="comment">//Plugin can write</span></div><div class="line">                <span class="keywordtype">int</span>* some_integer = ref_w.get();</div><div class="line">            } <span class="keywordflow">else</span> {</div><div class="line">                <span class="comment">//Plugin cannot read nor write</span></div><div class="line">            }</div><div class="line">        });</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">PDI_PLUGIN(example)</div></div><!-- fragment --><h2><a class="anchor" id="example_events"></a>
Handling events</h2>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;pdi/context.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/paraconf_wrapper.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/plugin.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/ref_any.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>example_plugin : <span class="keyword">public</span> <a class="code" href="classPDI_1_1Plugin.html">PDI::Plugin</a></div><div class="line">{</div><div class="line">    example_plugin(<a class="code" href="classPDI_1_1Context.html">PDI::Context</a>&amp; ctx, PC_tree_t spec_tree):</div><div class="line">        Plugin{ctx}</div><div class="line">    {</div><div class="line">        ctx.<a class="code" href="classPDI_1_1Context.html#a8aad7d27ce647a616bee1c911e274154">add_event_callback</a>([<span class="keyword">this</span>](<span class="keyword">const</span> std::string&amp; event_name){</div><div class="line">            this-&gt;handle_event(event_name);</div><div class="line">        });</div><div class="line">        ctx.add_event_callback([<span class="keyword">this</span>](<span class="keyword">const</span> std::string&amp; event_name){</div><div class="line">            this-&gt;handle_special_event(event_name);</div><div class="line">        }, <span class="stringliteral">&quot;special_event&quot;</span>);</div><div class="line">    }</div><div class="line"><span class="keyword">private</span>:</div><div class="line">    <span class="keywordtype">void</span> handle_event(<span class="keyword">const</span> std::string&amp; event_name) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Event&quot;</span> &lt;&lt; event_name &lt;&lt; <span class="stringliteral">&quot;called.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    }</div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> handle_special_event(<span class="keyword">const</span> std::string&amp; event_name) {</div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Special event `&quot;</span> &lt;&lt; event_name &lt;&lt; <span class="stringliteral">&quot;&#39; called.&quot;</span> &lt;&lt; std::endl;</div><div class="line">    } </div><div class="line">}</div><div class="line"></div><div class="line">PDI_PLUGIN(example)</div></div><!-- fragment --><h2><a class="anchor" id="reading_pc_tree"></a>
Reading scalar and array from specification tree</h2>
<p>Specification tree: </p><div class="fragment"><div class="line">plugins:</div><div class="line">  example:</div><div class="line">    scalar: some_string</div><div class="line">    array: [0, 1, 2]</div></div><!-- fragment --><p> Reading a scalar and an array: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;pdi/context.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/paraconf_wrapper.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/plugin.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/ref_any.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>example_plugin : <span class="keyword">public</span> <a class="code" href="classPDI_1_1Plugin.html">PDI::Plugin</a></div><div class="line">{</div><div class="line">    example_plugin(<a class="code" href="classPDI_1_1Context.html">PDI::Context</a>&amp; ctx, PC_tree_t spec_tree):</div><div class="line">        Plugin{ctx}</div><div class="line">    {</div><div class="line">        <span class="comment">//scalar</span></div><div class="line">        PC_tree_t scalar_tree = PC_get(spec_tree, <span class="stringliteral">&quot;.scalar&quot;</span>);</div><div class="line">        std::string string_scalar = <a class="code" href="namespacePDI.html#ae1a842c5cdb57b5185c035de9a99c3c8">PDI::to_string</a>(scalar_tree);</div><div class="line"></div><div class="line">        <span class="comment">//array</span></div><div class="line">        PC_tree_t array_tree = PC_get(spec_tree, <span class="stringliteral">&quot;.array&quot;</span>);</div><div class="line">        <span class="keywordtype">int</span> array_size = <a class="code" href="namespacePDI.html#a00f2173a7fb0dc37655e9e39756e135e">PDI::len</a>(array_tree);</div><div class="line">        std::vector&lt;long&gt; array;</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; array_size; i++) {</div><div class="line">            PC_tree_t array_element = PC_get(array_tree, <span class="stringliteral">&quot;[%d]&quot;</span>, i);</div><div class="line">            array.emplace_back(<a class="code" href="namespacePDI.html#ac4e2b53893618edfb9bff90c65c4ee01">PDI::to_long</a>(array_element));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">PDI_PLUGIN(example)</div></div><!-- fragment --> <h2><a class="anchor" id="reading_pc_tree_2"></a>
Reading maps from specification tree</h2>
<p>Specification tree: </p><div class="fragment"><div class="line">plugins:</div><div class="line">  example:</div><div class="line">    custom_subtree:</div><div class="line">        here: 0</div><div class="line">        can: 1</div><div class="line">        be: 2</div><div class="line">        any: 3</div><div class="line">        subtree: 4</div></div><!-- fragment --><p> Reading a scalar and an array: </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;unordered_map&gt;</span></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;pdi/context.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/paraconf_wrapper.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/plugin.h&gt;</span></div><div class="line"><span class="preprocessor">#include &lt;pdi/ref_any.h&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">struct </span>example_plugin : <span class="keyword">public</span> <a class="code" href="classPDI_1_1Plugin.html">PDI::Plugin</a></div><div class="line">{</div><div class="line">    example_plugin(<a class="code" href="classPDI_1_1Context.html">PDI::Context</a>&amp; ctx, PC_tree_t spec_tree):</div><div class="line">        Plugin{ctx}</div><div class="line">    {</div><div class="line">        PC_tree_t subtree = PC_get(spec_tree, <span class="stringliteral">&quot;.custom_subtree&quot;</span>);</div><div class="line">        <span class="keywordtype">int</span> subtree_size = <a class="code" href="namespacePDI.html#a00f2173a7fb0dc37655e9e39756e135e">PDI::len</a>(subtree);</div><div class="line">        std::unordered_map&lt;std::string, long&gt; custom_map;</div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; subtree_size; i++) {</div><div class="line">            PC_tree_t key = PC_get(subtree, <span class="stringliteral">&quot;{%d}&quot;</span>, i);</div><div class="line">            PC_tree_t value = PC_get(subtree, <span class="stringliteral">&quot;&lt;%d&gt;&quot;</span>, i);</div><div class="line">            custom_map.emplace_back(<a class="code" href="namespacePDI.html#ae1a842c5cdb57b5185c035de9a99c3c8">PDI::to_string</a>(key), <a class="code" href="namespacePDI.html#ac4e2b53893618edfb9bff90c65c4ee01">PDI::to_long</a>(value));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line">PDI_PLUGIN(example)</div></div><!-- fragment --><h1><a class="anchor" id="create_true_plugin"></a>
Creating a true plugin: POSIX plugin</h1>
<h2><a class="anchor" id="step_1"></a>
Step 1: Think what your plugin will be for.</h2>
<p>Simple checkpointing. Each data will be saved in separate file. User can check the status of all files at once and then recover the data.</p>
<h2><a class="anchor" id="step_2"></a>
Step 2: Prepare your specification tree schema.</h2>
<div class="fragment"><div class="line">data:</div><div class="line">  some_data: {type: array, subtype: int, size: 64}</div><div class="line">  can_recover_data: int</div><div class="line"></div><div class="line">plugins:</div><div class="line">  posix:</div><div class="line">    data:</div><div class="line">      some_data: /file_path/</div><div class="line">    can_recover_all: can_recover_data</div></div><!-- fragment --><p> /file_path/ is a path where to save and load from some_data. can_recover_data is a flag that indicates if the recover is possible.</p>
<p>The fastest way to learn is by examples. To show how to create a plugin, we will create "posix plugin". It won't do anything special, but give you a basic knowledge how to create one.</p>
<h2><a class="anchor" id="step_3"></a>
Step 3: Write your plugin.</h2>
<p>Members and constructor: </p><div class="fragment"><div class="line"><span class="keyword">class </span>posix_plugin : <span class="keyword">public</span> <a class="code" href="classPDI_1_1Plugin.html">PDI::Plugin</a></div><div class="line">{</div><div class="line">    std::string m_can_recover_data;</div><div class="line">    std::unordered_map&lt;std::string, std::string&gt; m_data_to_path_map;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    posix_plugin(<a class="code" href="classPDI_1_1Context.html">PDI::Context</a>&amp; ctx, PC_tree_t spec_tree):</div><div class="line">        Plugin{ctx}</div><div class="line">    {}</div><div class="line">}</div><div class="line"></div><div class="line">PDI_PLUGIN(posix)</div></div><!-- fragment --><p>Read recover tree: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> read_recover_tree(PC_tree_t spec_tree) {</div><div class="line">    PC_tree_t recover_tree = PC_get(spec_tree, <span class="stringliteral">&quot;.can_recover_all&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span>(!PC_status(recover_tree)) {</div><div class="line">        m_can_recover_data = <a class="code" href="namespacePDI.html#ae1a842c5cdb57b5185c035de9a99c3c8">PDI::to_string</a>(recover_tree);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Read data tree: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> read_data_tree(PC_tree_t spec_tree) {</div><div class="line">    PC_tree_t data_tree = PC_get(spec_tree, <span class="stringliteral">&quot;.data&quot;</span>);</div><div class="line">    <span class="keywordflow">if</span> (!PC_status(data_tree)) {</div><div class="line">        <span class="keywordtype">int</span> data_tree_size = <a class="code" href="namespacePDI.html#a00f2173a7fb0dc37655e9e39756e135e">PDI::len</a>(data_tree);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; data_tree_size; i++) {</div><div class="line">            PC_tree_t key = PC_get(data_tree, <span class="stringliteral">&quot;{%d}&quot;</span>, i);</div><div class="line">            PC_tree_t value = PC_get(data_tree, <span class="stringliteral">&quot;&lt;%d&gt;&quot;</span>, i);</div><div class="line">            m_data_to_path_map.emplace_back(<a class="code" href="namespacePDI.html#ae1a842c5cdb57b5185c035de9a99c3c8">PDI::to_string</a>(key), <a class="code" href="namespacePDI.html#ae1a842c5cdb57b5185c035de9a99c3c8">PDI::to_string</a>(value));</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Create a function that writes data to temporary file and check if file was created, size is correct and then replace old file: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> write_data(<span class="keyword">const</span> std::string&amp; data_name, <a class="code" href="classPDI_1_1Ref__any.html">PDI::Ref_r</a> ref_r) {</div><div class="line">    <span class="keywordflow">if</span>(!ref_r) {</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">    std::string tmp_path = m_data_to_path_map[data_name] + <span class="stringliteral">&quot;.tmp&quot;</span>;</div><div class="line">    std::ofstream file{tmp_path, std::ios::binary};</div><div class="line">    <span class="keywordflow">if</span> (ref_r.<a class="code" href="classPDI_1_1Reference__base.html#a281fb6b0fae3cfb5781af75858831131">type</a>().<a class="code" href="classPDI_1_1Datatype.html#a341a15d47396f1cd9bb12e43a5cd5a40">buffersize</a>() == ref_r.<a class="code" href="classPDI_1_1Reference__base.html#a281fb6b0fae3cfb5781af75858831131">type</a>().<a class="code" href="classPDI_1_1Datatype.html#aa5254560c8fd98403b2067091f93b3c9">datasize</a>()) {</div><div class="line">        <span class="comment">//dense data</span></div><div class="line">        file.write((<span class="keyword">const</span> <span class="keywordtype">char</span>*)ref_r.<a class="code" href="classPDI_1_1Ref__any.html#ad8d6851233a405e0e1c27d2e762c6cb9">get</a>(), ref_r.<a class="code" href="classPDI_1_1Reference__base.html#a281fb6b0fae3cfb5781af75858831131">type</a>().<a class="code" href="classPDI_1_1Datatype.html#a341a15d47396f1cd9bb12e43a5cd5a40">buffersize</a>());</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">//sparse data</span></div><div class="line">        std::unique_ptr&lt;char&gt; data_copy {<span class="keyword">new</span> <span class="keywordtype">char</span>[ref_r.<a class="code" href="classPDI_1_1Reference__base.html#a281fb6b0fae3cfb5781af75858831131">type</a>().dataSize()]};</div><div class="line">        ref_r.<a class="code" href="classPDI_1_1Reference__base.html#a281fb6b0fae3cfb5781af75858831131">type</a>().<a class="code" href="classPDI_1_1Datatype.html#a988bab02472c4dc4206b40cd093030c3">data_to_dense_copy</a>(data_copy.get(), ref_r.<a class="code" href="classPDI_1_1Ref__any.html#ad8d6851233a405e0e1c27d2e762c6cb9">get</a>());</div><div class="line">        file.write(data_copy.get(), ref_r.<a class="code" href="classPDI_1_1Reference__base.html#a281fb6b0fae3cfb5781af75858831131">type</a>().<a class="code" href="classPDI_1_1Datatype.html#aa5254560c8fd98403b2067091f93b3c9">datasize</a>());</div><div class="line">    }</div><div class="line">    file.close();</div><div class="line"></div><div class="line">    <span class="comment">//replace old file</span></div><div class="line">    <span class="keyword">struct </span>stat status;</div><div class="line">    <span class="keywordflow">if</span> (!stat(tmp_path.c_str(), &amp;status) &amp;&amp; status.st_size == ref_r.<a class="code" href="classPDI_1_1Reference__base.html#a281fb6b0fae3cfb5781af75858831131">type</a>().<a class="code" href="classPDI_1_1Datatype.html#aa5254560c8fd98403b2067091f93b3c9">datasize</a>()) {</div><div class="line">        <span class="keywordflow">if</span> (!stat(m_data_to_path_map[data_name].c_str()) &amp;&amp; std::remove(m_data_to_path_map[data_name].c_str())) {</div><div class="line">            <span class="keywordflow">throw</span> <a class="code" href="classPDI_1_1Error.html">PDI::Error</a> {<a class="code" href="group__error.html#gga838ed1a4a5ca21c0d3ef790afbf61b74a9b282d8284fbacc7a4fd81e81964260b">PDI_ERR_SYSTEM</a>, <span class="stringliteral">&quot;Cannot remove old file {}&quot;</span>, m_data_to_path_map[data_name]};</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (std::rename(tmp_path.c_str(), m_data_to_path_map[data_name].c_str())) {</div><div class="line">            <span class="keywordflow">throw</span> <a class="code" href="classPDI_1_1Error.html">PDI::Error</a> {<a class="code" href="group__error.html#gga838ed1a4a5ca21c0d3ef790afbf61b74a9b282d8284fbacc7a4fd81e81964260b">PDI_ERR_SYSTEM</a>, <span class="stringliteral">&quot;Cannot rename temporary file {}&quot;</span>, tmp_path};</div><div class="line">        }</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="keywordflow">throw</span> <a class="code" href="classPDI_1_1Error.html">PDI::Error</a> {<a class="code" href="group__error.html#gga838ed1a4a5ca21c0d3ef790afbf61b74a9b282d8284fbacc7a4fd81e81964260b">PDI_ERR_SYSTEM</a>, <span class="stringliteral">&quot;Data write not complete&quot;</span>};</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Create a function that reads data from file: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> read_data(<span class="keyword">const</span> std::string&amp; data_name, <a class="code" href="classPDI_1_1Ref__any.html">PDI::Ref_w</a> ref_w) {</div><div class="line">    <span class="keywordflow">if</span>(!ref_w) {</div><div class="line">        <span class="keywordflow">return</span>;</div><div class="line">    }</div><div class="line">    std::ifstream file{m_data_to_path_map[data_name], std::ios::binary};</div><div class="line">    <span class="keywordflow">if</span> (ref_w.<a class="code" href="classPDI_1_1Reference__base.html#a281fb6b0fae3cfb5781af75858831131">type</a>().<a class="code" href="classPDI_1_1Datatype.html#a341a15d47396f1cd9bb12e43a5cd5a40">buffersize</a>() == ref_w.<a class="code" href="classPDI_1_1Reference__base.html#a281fb6b0fae3cfb5781af75858831131">type</a>().<a class="code" href="classPDI_1_1Datatype.html#aa5254560c8fd98403b2067091f93b3c9">datasize</a>()) {</div><div class="line">        <span class="comment">//dense data</span></div><div class="line">        file.read((<span class="keywordtype">char</span>*)ref_w.<a class="code" href="classPDI_1_1Ref__any.html#ad8d6851233a405e0e1c27d2e762c6cb9">get</a>(), ref_w.<a class="code" href="classPDI_1_1Reference__base.html#a281fb6b0fae3cfb5781af75858831131">type</a>().<a class="code" href="classPDI_1_1Datatype.html#a341a15d47396f1cd9bb12e43a5cd5a40">buffersize</a>());</div><div class="line">    } <span class="keywordflow">else</span> {</div><div class="line">        <span class="comment">//sparse data</span></div><div class="line">        std::unique_ptr&lt;char&gt; data_copy {<span class="keyword">new</span> <span class="keywordtype">char</span>[ref_w.<a class="code" href="classPDI_1_1Reference__base.html#a281fb6b0fae3cfb5781af75858831131">type</a>().dataSize()]};</div><div class="line">        file.read(data_copy.get(), ref_w.<a class="code" href="classPDI_1_1Reference__base.html#a281fb6b0fae3cfb5781af75858831131">type</a>().<a class="code" href="classPDI_1_1Datatype.html#aa5254560c8fd98403b2067091f93b3c9">datasize</a>());</div><div class="line">        ref_w.<a class="code" href="classPDI_1_1Reference__base.html#a281fb6b0fae3cfb5781af75858831131">type</a>().<a class="code" href="classPDI_1_1Datatype.html#a00559b1afaf47436b64a26841b486a14">data_from_dense_copy</a>(ref_w.<a class="code" href="classPDI_1_1Ref__any.html#ad8d6851233a405e0e1c27d2e762c6cb9">get</a>(), data_copy.get());</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Handle can_recover_all data: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> can_recover(<span class="keyword">const</span> std::string&amp; data_name, <a class="code" href="classPDI_1_1Ref__any.html">PDI::Ref_w</a> ref_w) {</div><div class="line">    <span class="keywordflow">if</span> (!ref_w) {</div><div class="line">        <span class="keywordflow">throw</span> <a class="code" href="classPDI_1_1Error.html">PDI::Error</a> {<a class="code" href="group__error.html#gga838ed1a4a5ca21c0d3ef790afbf61b74ae573fb10e871f40c2b37182ff415f454">PDI_ERR_RIGHT</a>, <span class="stringliteral">&quot;Cannot write to `can_recover_all&#39; data&quot;</span>};</div><div class="line">    }</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; data_path_pair : m_data_to_path_map) {</div><div class="line">        <span class="keyword">struct </span>stat status;</div><div class="line">        <span class="keywordflow">if</span> (stat(data_path_pair.second.c_str(), &amp;status)) {</div><div class="line">            *<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(ref_w.<a class="code" href="classPDI_1_1Ref__any.html#ad8d6851233a405e0e1c27d2e762c6cb9">get</a>()) = 0;</div><div class="line">            <span class="keywordflow">return</span>;</div><div class="line">        }</div><div class="line">    }</div><div class="line">    *<span class="keyword">static_cast&lt;</span><span class="keywordtype">int</span>*<span class="keyword">&gt;</span>(ref_w.<a class="code" href="classPDI_1_1Ref__any.html#ad8d6851233a405e0e1c27d2e762c6cb9">get</a>()) = 1;</div><div class="line">}</div></div><!-- fragment --><p>Add created functions to callbacks: </p><div class="fragment"><div class="line"><span class="keyword">class </span>posix_plugin : <span class="keyword">public</span> <a class="code" href="classPDI_1_1Plugin.html">PDI::Plugin</a></div><div class="line">{</div><div class="line">    std::string m_can_recover_data;</div><div class="line">    std::unordered_map&lt;std::string, std::string&gt; m_data_to_path_map;</div><div class="line"></div><div class="line"><span class="keyword">public</span>:</div><div class="line">    posix_plugin(<a class="code" href="classPDI_1_1Context.html">PDI::Context</a>&amp; ctx, PC_tree_t spec_tree):</div><div class="line">        Plugin{ctx}</div><div class="line">    {</div><div class="line">        read_recover_tree(spec_tree);</div><div class="line">        read_data_tree(spec_tree);</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; data_path_pair : m_data_to_path_map) {</div><div class="line">            ctx.add_data_callback([<span class="keyword">this</span>](<span class="keyword">const</span> std::string&amp; data_name, <a class="code" href="classPDI_1_1Ref__any.html">PDI::Ref</a> ref) {</div><div class="line">                this-&gt;write_data(data_name, ref);</div><div class="line">            }, data_path_pair.first);</div><div class="line">            ctx.add_data_callback([<span class="keyword">this</span>](<span class="keyword">const</span> std::string&amp; data_name, <a class="code" href="classPDI_1_1Ref__any.html">PDI::Ref</a> ref) {</div><div class="line">                this-&gt;read_data(data_name, ref);</div><div class="line">            }, data_path_pair.first);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">if</span> (!m_can_recover_data.empty()) {</div><div class="line">            ctx.add_data_callback([<span class="keyword">this</span>](<span class="keyword">const</span> std::string&amp; data_name, <a class="code" href="classPDI_1_1Ref__any.html">PDI::Ref</a> ref) {</div><div class="line">                this-&gt;can_recover(data_name, ref);</div><div class="line">            }, m_can_recover_all_data);</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><h2><a class="anchor" id="plugin_compile"></a>
Next steps</h2>
<ol type="1">
<li>Compile: g++ posix.cxx -o libpdi_posix_plugin.so -lpdi -shared -fPIC -std=c++11</li>
<li>Copy created file to path where dynamic linker can find it. For example: sudo cp libpdi_posix_plugin.so /usr/local/lib/</li>
<li>Configure dynamic linker run-time bindings: sudo ldconfig</li>
<li>Create program that uses posix plugin.</li>
<li>Compile your test program: gcc example_use.cxx -o example_use -lpdi -lparaconf</li>
<li>Run your test program: ./example_use</li>
</ol>
<p>You can see example of the program that uses this plugin on these <a href="https://docs.google.com/presentation/d/1jT416oALDkquBBgq_XkVrU48o4qx72wGHUPb4emXJw4">slides</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
</body>
</html>
