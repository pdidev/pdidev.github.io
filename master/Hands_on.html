<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="generator" content="Doxygen 1.8.13"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>PDI: Hands-on tutorial</title>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<script type="text/javascript" src="navtreedata.js"></script>
	<script type="text/javascript" src="navtree.js"></script>
	<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div>
<header id="titlearea">
	<div id="projectlogo"><a href="index.html"><img alt="Logo" src="logo.png"/></a></div>
	<h1 id="projectname">PDI&nbsp;<span id="projectnumber">1.2.0-alpha.2021-03-02.f30a1e4</span></h1>
	<h2 id="projectbrief">Data exchange made easy</h2>
</header>
<nav id="tabs"><ul>
	<li><a href="index.html">About</a>
	<li><a href="Installation.html">Installation</a>
	<li><a href="PDI_usage.html">PDI usage</a>
	<li><a href="Concepts.html">Core concepts</a>
	<li><a href="First_steps.html">First steps</a>
	<li><a href="Hands_on.html">Tutorial</a>
	<li><a href="PDI_example.html">PDI example</a>
	<li><a href="modules.html">C API reference</a>
	<li><a href="Specification_tree_ref.html">Specification tree</a>
	<li><a href="Plugins.html">Plugins</a>
	<li id="gitlab-ribbon"><a href="https://gitlab.maisondelasimulation.fr/pdidev/pdi">Contribute on Gitlab</a></li>
</ul></nav>
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('Hands_on.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Hands-on tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In this tutorial, you will build a PDI-enabled application step-by-step from a PDI-free base. You will end-up building the C version of the <a class="el" href="PDI_example.html">example provided with PDI</a> for the the <a class="el" href="trace_plugin.html">Trace</a>, <a class="el" href="Decl_HDF5_plugin.html">Decl'HDF5</a>, and <a class="el" href="pycall_plugin.html">Pycall</a> plugins. Additional <a href="https://gitlab.maisondelasimulation.fr/pdidev/pdi/-/tree/master/example">examples are available for the other plugins</a>.</p>
<h1><a class="anchor" id="autotoc_md14"></a>
Setup</h1>
<h2><a class="anchor" id="autotoc_md15"></a>
PDI Installation</h2>
<p>To run this hands-on tutorial, you will of course first need to <a class="el" href="Installation.html">install PDI</a> and setup your environment.</p>
<p>On Juwels, <a class="el" href="namespacePDI.html">PDI</a> is pre-installed as part of the training2022 environment. To load it, just run: </p><div class="fragment"><div class="line">source /p/project/training2022/setup</div></div><!-- fragment --><h2><a class="anchor" id="autotoc_md16"></a>
Setup the hands-on tutorial</h2>
<p>Once PDI is installed, you can proceed with getting the sources for the hands-on tutorial from <a href="https://github.com/pdidev/tutorial">github</a>: </p><div class="fragment"><div class="line">git clone https://github.com/pdidev/tutorial.git</div><div class="line">cd tutorial</div></div><!-- fragment --><p>On Juwels, you can just copy the content from <code>${PROJECT_training2022}/PDI_tutorial</code>: </p><div class="fragment"><div class="line">cp -R ${PROJECT_training2022}/PDI_tutorial .</div><div class="line">cd PDI_tutorial</div></div><!-- fragment --><h2><a class="anchor" id="autotoc_md17"></a>
compilation</h2>
<p>Before compilation, configure the tutorial by detecting all dependencies: </p><div class="fragment"><div class="line">cmake -B build .</div></div><!-- fragment --><p>For each exercise, once you've modified it, you can compile it by running the following command: </p><div class="fragment"><div class="line">make ex?</div></div><!-- fragment --><p> Where <code>?</code> is the number of the exercise.</p>
<h2><a class="anchor" id="autotoc_md18"></a>
Execution</h2>
<p>In order to speedup the execution on Juwels, it's a good idea to use <code>salloc</code> to reserve one node: </p><div class="fragment"><div class="line">salloc --reservation=parallel-io-day2 -N 1</div></div><!-- fragment --><p>You can run each exercise with the following command: </p><div class="fragment"><div class="line">srun -n 4 ./ex?</div></div><!-- fragment --><p> Where <code>?</code> is the number of the exercise and 4 represents the number of MPI processes to use.</p>
<p>Now you're ready to work, <b>good luck</b>!</p>
<h1><a class="anchor" id="autotoc_md19"></a>
PDI-free code</h1>
<h2><a class="anchor" id="autotoc_md20"></a>
Ex1. Getting started</h2>
<p>Ex1. implements a simple heat equation solver using an explicit forward finite difference scheme parallelized with MPI. The code uses a block domain decomposition where each process holds a 2D block of data.</p>
<div class="image">
<img src="heat_global_matrix.jpg" alt="heat_global_matrix.jpg"/>
<div class="caption">
Data domain decomposition in the example</div></div>
<p> Locally, each process holds its local block of data with one additional element on each side for ghost zones.</p>
<div class="image">
<img src="heat_local_matrix.jpg" alt="heat_local_matrix.jpg"/>
<div class="caption">
Data domain decomposition in the example</div></div>
<p> In the following exercises however, PDI will only be used to decouple I/O operations. There is no need to fully dive in the core of the solver described in the <a class="el" href="PDI_example.html#heat_algorithm">PDI example algorithm</a> and implemented in the <code>iter</code> and <code>exchange</code> functions.</p>
<p>The specification tree in the <code>.yml</code> files and the <code>main</code> function are the locations where all the I/O-related aspects will be handled and the only ones you will actually need to fully understand or modify.</p>
<ul>
<li>Examine the source code, compile it and run it. There is no input/output operations in the code yet, so you can not see any result.</li>
</ul>
<p>This example gets its configuration from a file in the <a class="el" href="YAML.html">YAML format</a>: <code>ex1.yml</code> file. If you're not familiar with YAML, please have a look at our quick <a class="el" href="YAML.html">YAML format documentation</a> to understand it. The example uses the <a href="https://github.com/pdidev/paraconf">paraconf library</a> to read this file.</p>
<ul>
<li>Play with and understand the code parameters in <code>ex1.yml</code>.</li>
<li>Set values in <code>ex1.yml</code> to be able to run the code with 4 MPI processes.</li>
</ul>
<div class="fragment"><div class="line">srun -n 4 ./ex1</div></div><!-- fragment --><h1><a class="anchor" id="autotoc_md21"></a>
PDI core &amp; trace plugin</h1>
<h2><a class="anchor" id="autotoc_md22"></a>
Ex2. Now with some PDI</h2>
<p>Ex2. is the same code as that of ex1. with PDI calls added in <code>main</code> function. In our YAML file (<code>ex2.yml</code>), a new sub-tree has been added under the <code>pdi</code> key. This sub-tree is the PDI specification tree passed to PDI at initialization. Here, the PDI <a class="el" href="trace_plugin.html">Trace plugin</a> is used to trace PDI calls.</p>
<ul>
<li>Examine the source code, compile it and run it.</li>
<li>Add the required <code><a class="el" href="group__annotation.html#ga34e34cede8627c47c07e6ede997e37fe" title="Shares some data with PDI. ">PDI_share</a></code> and <code><a class="el" href="group__annotation.html#gabf58b7c146cbf7e3341245f60cec0f7e" title="Reclaims ownership of a data buffer shared with PDI. ">PDI_reclaim</a></code> calls to match the output of <code>ex2.log</code> file. Change only the <code>ex2.c</code> file. The calls for now don't need to make any logic, just match output to the <code>ex2.log</code>.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>Notice that some share/reclaim pairs come one after the other while others are interlaced. Is one better than the other? If you do not know the answer to this question, just wait until Ex5. :)</dd></dl>
<h1><a class="anchor" id="autotoc_md23"></a>
Decl'HDF5 plugin</h1>
<h2><a class="anchor" id="autotoc_md24"></a>
Ex3. HDF5 through PDI</h2>
<p>In this exercise, the code is the same as in ex2. No need to touch the C code here, modification of the YAML file (<code>ex3.yml</code>) should be enough.</p>
<ul>
<li>Examine the YAML file, compile the code and run it.</li>
</ul>
<p>The <a class="el" href="trace_plugin.html">Trace plugin</a> (<code>trace</code>) was replaced by the <a class="el" href="Decl_HDF5_plugin.html">Decl'HDF5 plugin</a> (<code>decl_hdf5</code>) in the specification tree. In its configuration, the <code>dsize</code> variable is written.</p>
<ul>
<li>Write the <code>psize</code> and <code>pcoord</code> variables in addition to <code>dsize</code> to match the content expected as described in the <code>ex3.h5dump</code> file (use the <code>h5dump</code> command to see the content of the HDF5 file).</li>
</ul>
<p>To achieve this result, you will need to fill 2 sections in the YAML file.</p>
<ol type="1">
<li>The <code>data</code> section to indicate to PDI the <a class="el" href="Specification_tree_ref.html#datatype_node">datatype</a> type of the fields that are exposed.</li>
<li>The <code>decl_hdf5</code> section for the configuration of the <a class="el" href="Decl_HDF5_plugin.html">Decl'HDF5 plugin</a>.</li>
</ol>
<dl class="section warning"><dt>Warning</dt><dd>If you relaunch the executable, remember to delete your old <code>ex3.h5</code> file before, otherwise the data will not be changed.</dd>
<dd>
Since we write to the same location independently of the MPI rank, this exercise will fail if more than one MPI rank is used.</dd></dl>
<h2><a class="anchor" id="autotoc_md25"></a>
Ex4. Writing some real data</h2>
<p>In this exercise each MPI process will write its local 2D array block contained in the <code>main_field</code> variable to a separate HDF5 file. Once again, this can be done by modifying the YAML file only, no nee to touch the C file.</p>
<ul>
<li>Examine the YAML file, compile the code and run it.</li>
</ul>
<p>Notice that in the YAML file, a list was used in the <code>decl_hdf5</code> section with multiple write blocks instead of a single one as before in order to write to multiple files.</p>
<p>Also notice that this example now runs in parallel with two processes. Therefore it uses "$-expressions" to specify the file names and ensure we do not write to the same file from distinct ranks.</p>
<p>Unlike the other fields manipulated until now, the type of <code>main_field</code> is not fully known, its size is dynamic. By moving other fields in the <code>metadata</code> section, you can reference them from "$-expressions" in the configuration file.</p>
<ul>
<li>Use a $-expression to specify the size of <code>main_field</code>.</li>
</ul>
<p>Unlike the other fields manipulated until now, <code>main_field</code> is exposed multiple times along execution. In order not to overwrite it every time it is exposed, you need to add a <code>when</code> condition to restrict its output.</p>
<ul>
<li>Only write <code>main_field</code> at the second iteration (when <code>ii==1</code>) and match the expected content as described in <code>ex4.h5dump</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md26"></a>
Ex5. Introducing events</h2>
<p>In ex4., two variables were written to <code>ex4-data*.h5</code>, but the file was opened and closed for each and every write. Since Decl'HDF5 only sees the data appear one after the other, it does not keep the file open. Since <code>ii</code> and <code>main_field</code> are shared in an interlaced way, they are both available to PDI at the same time and could be written without opening the file twice. You have to use events for that, you will modify both the C and YAML file.</p>
<ul>
<li>Examine the YAML file and source code, compile and run.</li>
<li>In the C file, trigger a PDI event named <code>loop</code> when both <code>ii</code> and <code>main_field</code> are shared. With the <a class="el" href="trace_plugin.html">Trace plugin</a>, check that the event is indeed triggered at the expected time as described in <code>ex5.log</code>.</li>
<li>Use the <code>on_event</code> mechanism to trigger the write of <code>ii</code> and <code>main_field</code>. This mechanism can be combined with a <code>when</code> directive, in that case the write is only executed when both mechanisms agree.</li>
<li>Also notice the extended syntax that make it possible to write data to a dataset whose name differs from the PDI variable name. Use this mechanism to write <code>main_field</code> at iterations 1 and 2, in two distinct groups <code>iter1</code> and <code>iter2</code>. Your output should match the content described in <code>ex5.h5dump</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md27"></a>
Ex6. Simplifying the code</h2>
<p>As you can notice, the PDI code is quite redundant. In this exercise, you will use <code><a class="el" href="group__annotation.html#gabf3f81774644eff9a3cf511e57273454" title="Shortly exposes some data to PDI. ">PDI_expose</a></code> and <code><a class="el" href="group__annotation.html#gae5c670b378e423e3083122f62c1f0a59" title="Performs multiple exposes at once. ">PDI_multi_expose</a></code> to simplify the code while keeping the exact same behaviour. For once, there is no need to modify the YAML file here, you only need to modify the C file in this exercise.</p>
<ul>
<li>Examine the source code, compile it and run it.</li>
</ul>
<p>There are lots of matched <code><a class="el" href="group__annotation.html#ga34e34cede8627c47c07e6ede997e37fe" title="Shares some data with PDI. ">PDI_share</a></code>/<code><a class="el" href="group__annotation.html#gabf58b7c146cbf7e3341245f60cec0f7e" title="Reclaims ownership of a data buffer shared with PDI. ">PDI_reclaim</a></code> in the code.</p>
<ul>
<li>Replace these by <code><a class="el" href="group__annotation.html#gabf3f81774644eff9a3cf511e57273454" title="Shortly exposes some data to PDI. ">PDI_expose</a></code> that is the exact equivalent of a <code><a class="el" href="group__annotation.html#ga34e34cede8627c47c07e6ede997e37fe" title="Shares some data with PDI. ">PDI_share</a></code> followed by a matching <code><a class="el" href="group__annotation.html#gabf58b7c146cbf7e3341245f60cec0f7e" title="Reclaims ownership of a data buffer shared with PDI. ">PDI_reclaim</a></code>.</li>
</ul>
<p>This replacement is not possible for interlaced <code><a class="el" href="group__annotation.html#ga34e34cede8627c47c07e6ede997e37fe" title="Shares some data with PDI. ">PDI_share</a></code>/<code><a class="el" href="group__annotation.html#gabf58b7c146cbf7e3341245f60cec0f7e" title="Reclaims ownership of a data buffer shared with PDI. ">PDI_reclaim</a></code> with events in the middle. This case is however handled by <code><a class="el" href="group__annotation.html#gae5c670b378e423e3083122f62c1f0a59" title="Performs multiple exposes at once. ">PDI_multi_expose</a></code> call that exposes all data, then triggers an event and finally does all the reclaim in reverse order.</p>
<ul>
<li>Replace the remaining <code><a class="el" href="group__annotation.html#ga34e34cede8627c47c07e6ede997e37fe" title="Shares some data with PDI. ">PDI_share</a></code>/<code><a class="el" href="group__annotation.html#gabf58b7c146cbf7e3341245f60cec0f7e" title="Reclaims ownership of a data buffer shared with PDI. ">PDI_reclaim</a></code> by <code><a class="el" href="group__annotation.html#gabf3f81774644eff9a3cf511e57273454" title="Shortly exposes some data to PDI. ">PDI_expose</a></code>s and <code><a class="el" href="group__annotation.html#gae5c670b378e423e3083122f62c1f0a59" title="Performs multiple exposes at once. ">PDI_multi_expose</a></code>s and ensure that your code keeps the exact same behaviour by comparing its trace to <code>ex6.log</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
Ex7. Writing a selection</h2>
<p>In this exercise, you will only write a selection of the 2D array in memory excluding ghosts to the HDF5 file. Once again, you only need to modify the YAML file in this exercise, no need to touch the C file.</p>
<ul>
<li>Examine the YAML file, compile the code and run it.</li>
</ul>
<p>As you can notice, now the dataset is independently described in the file.</p>
<ul>
<li>Restrict the selection to the non-ghost part of the array in memory (excluding one element on each side). You should be able to match the expected output described in <code>ex7.h5dump</code>.</li>
</ul>
<p>You can achieve this by using the <code>memory_selection</code> directive that specifies the selection of data from memory to write.</p>
<div class="image">
<img src="PDI_hdf5_selection.jpg" alt="PDI_hdf5_selection.jpg"/>
<div class="caption">
graphical representation</div></div>
<h2><a class="anchor" id="autotoc_md29"></a>
Ex8. Selecting on the dataset size</h2>
<p>In this exercise, you will once again change the YAML file to handle a selection in the dataset in addition to the selection in memory from the previous exercise. You will write the 2D array from the previous exercise as a slice of 3D dataset including a dimension for time. Once again, you only need to modify the YAML file in this exercise, no need to touch the C file.</p>
<ul>
<li>Examine the YAML file, compile the code and run it.</li>
</ul>
<p>Notice how the dataset is now extended with an additional dimension for three time-steps.</p>
<ul>
<li>Write the 2D selection from <code>main_field</code> at iterations 1 to 3 inclusive into slices at coordinate 0 to 2 of first dimension of the 3D dataset. Match the expected output described in <code>ex8.h5dump</code>.</li>
</ul>
<p>You can achieve this by using the <code>dataset_selection</code> directive that specifies the selection where to write in the file dataset.</p>
<div class="image">
<img src="PDI_hdf5_selection_advanced.jpg" alt="PDI_hdf5_selection_advanced.jpg"/>
<div class="caption">
graphical representation</div></div>
<h1><a class="anchor" id="autotoc_md30"></a>
parallel Decl'HDF5</h1>
<h2><a class="anchor" id="autotoc_md31"></a>
Ex9. Going parallel</h2>
<p>Running the code from the previous exercises in parallel should already work and yield one file per process containing the local data block. In this exercise you will write one single file with parallel HDF5 whose content should be independent from the number of processes used. Once again, you only need to modify the YAML file in this exercise, no need to touch the C file.</p>
<ul>
<li>Examine the YAML file, compile the code and run it.</li>
</ul>
<p>The <code>mpi</code> plugin was loaded to make sharing MPI communicators possible.</p>
<ul>
<li>Uncomment the <code>communicator</code> directive of the <a class="el" href="Decl_HDF5_plugin.html">Decl'HDF5 plugin</a> to switch to parallel I/O and change the file name so that all processes access the same file.</li>
<li>Set the size of the dataset to take the global (parallel) array size into account. You will need to multiply the local size by the number of processes in each dimension (use <code>psize</code>).</li>
<li>Ensure the dataset selection of each process does not overlap with the others. You will need to make a selection in the dataset that depends on the global coordinate of the local data block (use <code>pcoord</code>).</li>
</ul>
<p>Match the output from <code>ex9.h5dump</code>, that should be independent from the number of processes used.</p>
<div class="image">
<img src="PDI_hdf5_parallel.jpg" alt="PDI_hdf5_parallel.jpg"/>
<div class="caption">
graphical representation of the parallel I/O</div></div>
<h1><a class="anchor" id="autotoc_md32"></a>
Pycall</h1>
<h2><a class="anchor" id="autotoc_md33"></a>
Ex10. Post-processing the data in python</h2>
<p>In this exercise, you will once again modify the YAML file only and use python to post-process the data in situ before writing it to HDF5. Here, you will write the exponential of the raw data to HDF5 instead of the data itself.</p>
<ul>
<li>Examine the YAML file, compile the code and run it.</li>
</ul>
<p>Notice that the Decl'HDF5 configuration was simplified, no memory selection is applied, the when condition disappeared. The dataset name is however explicitly specified now because it does not match the PDI variable name anymore, you will instead write a new variable exposed from python.</p>
<p>The <code>pycall</code> section has been added to load the <a class="el" href="pycall_plugin.html">Pycall plugin</a>. It executes the provided code when the "loop" event is triggered. The <code>with</code> section specifies the variables (parameters) to pass to Python as a set of "$-expressions". The provided code again exposes its result to PDI and multiple blocks can be chained this way.</p>
<ul>
<li>Add the missing parameter to the <code>with</code> block to let the Python code process the data exposed in <code>main_field</code>.</li>
<li>Modify the Decl'HDF5 configuration to write the new data exposed from Python.</li>
</ul>
<dl class="section attention"><dt>Attention</dt><dd>In a more realistic setup, one would typically not write much code in the YAML file directly, but would instead call functions specified in a <code>.py</code> file on the side.</dd></dl>
<h1><a class="anchor" id="autotoc_md34"></a>
What next ?</h1>
<p>In this tutorial, you used the C API of PDI and from YAML, you used the <a class="el" href="trace_plugin.html">Trace</a>, <a class="el" href="Decl_HDF5_plugin.html">Decl'HDF5</a>, and <a class="el" href="pycall_plugin.html">Pycall</a> plugins.</p>
<p>If you want to try <a class="el" href="namespacePDI.html">PDI</a> from another language (Fortran, python, ...) or if you want to experiment with other <a class="el" href="Plugins.html">PDI plugins</a>, have a look at the <a href="https://gitlab.maisondelasimulation.fr/pdidev/pdi/-/tree/master/example">examples provided with PDI</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
</body>
</html>
