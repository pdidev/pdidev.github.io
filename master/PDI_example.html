<!DOCTYPE html>
<html>
<head>
	<meta charset="UTF-8">
	<meta name="generator" content="Doxygen 1.8.13"/>
	<meta name="viewport" content="width=device-width, initial-scale=1"/>
	<title>PDI: PDI example</title>
	<script type="text/javascript" src="jquery.js"></script>
	<script type="text/javascript" src="dynsections.js"></script>
	<script type="text/javascript" src="navtreedata.js"></script>
	<script type="text/javascript" src="navtree.js"></script>
	<link href="style.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div>
<header id="titlearea">
	<div id="projectlogo"><a href="index.html"><img alt="Logo" src="logo.png"/></a></div>
	<h1 id="projectname">PDI&nbsp;<span id="projectnumber">1.1.0-alpha.2021-03-01.8c8aeee</span></h1>
	<h2 id="projectbrief">Data exchange made easy</h2>
</header>
<nav id="tabs"><ul>
	<li><a href="index.html">About</a>
	<li><a href="Installation.html">Installation</a>
	<li><a href="PDI_usage.html">PDI usage</a>
	<li><a href="Concepts.html">Core concepts</a>
	<li><a href="First_steps.html">First steps</a>
	<li><a href="Hands_on.html">Tutorial</a>
	<li><a href="PDI_example.html">PDI example</a>
	<li><a href="modules.html">C API reference</a>
	<li><a href="Specification_tree_ref.html">Specification tree</a>
	<li><a href="Plugins.html">Plugins</a>
	<li id="gitlab-ribbon"><a href="https://gitlab.maisondelasimulation.fr/pdidev/pdi">Contribute on Gitlab</a></li>
</ul></nav>
<!-- Generated by Doxygen 1.8.13 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('PDI_example.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">PDI example </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>PDI example application can be found in repository in the <code>example</code> directory. The source code is written in C, Fortran and Python.</p>
<p>The example has a single source file (for each supported programming language), but specification tree to each plugin. Just by replacing the configuration file, the example program will use different libraries and different I/O operations.</p>
<p>The example implements simple <a href="https://en.wikipedia.org/wiki/Heat_equation">Heat equation</a> algorithm in 2 dimensional space.</p>
<h1><a class="anchor" id="heat_algorithm"></a>
Heat algorithm</h1>
<p>Each element in a matrix is a point with temperature. In each iteration every cell is calculated by an weighted average of itself and neighbour cells (top, bottom, left and right):</p>
<div class="fragment"><div class="line">matrix[i][j] = 0.500 * matrix[i][j] + </div><div class="line">               0.125 * matrix[i-1][j] +</div><div class="line">               0.125 * matrix[i+1][j] +</div><div class="line">               0.125 * matrix[i][j-1] +</div><div class="line">               0.125 * matrix[i][j+1]; </div></div><!-- fragment --><p> To not override the cells while processing we need to create temporary matrix to save results and then move result to original matrix (<code>cur</code> and <code>next</code> in source file). Above calculations are written in <code>iter</code> function.</p>
<p>Now we can add a MPI to our algorithm. Let's split that matrix by MPI processes. Each process will compute part of global matrix.</p>
<p>For example: matrix 16 x 16 integers and 16 MPI processes gives submatrices of 4 x 4 integers for every process. We have to add to our global matrix one row above and below, column to the left and right to be able to compute border cells. In our example row on the top has some value (”x”) bigger than 0 (representing source of heat):</p>
<div class="image">
<img src="heat_global_matrix.jpg" alt="heat_global_matrix.jpg"/>
</div>
<p>MPI processes need to exchange information about their local matrix border cells (communicate with neighbours to exchange row/column of matrix). Each MPI process will have a local matrix:</p>
<div class="image">
<img src="heat_local_matrix.jpg" alt="heat_local_matrix.jpg"/>
</div>
<p>All the communications instructions are written in <code>exchange</code> function.</p>
<h1><a class="anchor" id="pdi_integration"></a>
PDI integration</h1>
<p>Now, when we know the algorithm, we can focus on analysing <code>decl_hdf5.yaml</code> specification tree. Fisrt 3 maps defined will not be seen to PDI: </p><div class="fragment"><div class="line">duration: 0.75</div><div class="line">datasize: [60, 12]</div><div class="line">parallelism: { height: 3, width: 1 }</div></div><!-- fragment --><ul>
<li><code>duration</code> is the value in seconds how long the application will run.</li>
<li><code>datasize</code> is size of our global matrix.</li>
<li><code>parallelism</code> defines the number of MPI processes in each dimension.</li>
</ul>
<p>Next, we have defined <code>data</code> and <code>metadata</code>: </p><div class="fragment"><div class="line">pdi:</div><div class="line">  metadata:</div><div class="line">    iter:   int</div><div class="line">    dsize:  { size: 2, type: array, subtype: int }</div><div class="line">    psize:  { size: 2, type: array, subtype: int }</div><div class="line">    pcoord: { size: 2, type: array, subtype: int }</div><div class="line">  data:</div><div class="line">    main_field: { size: [ &#39;$dsize[0]&#39;, &#39;$dsize[1]&#39; ], type: array, subtype: double }</div></div><!-- fragment --><p>In source file we will extract the <code>pdi</code> map and pass it as PDI_init argument.</p><ul>
<li><code>iter</code> will hold the current iteration number.</li>
<li><code>dsize</code> will hold the size of local matrix of each MPI process.</li>
<li><code>psize</code> will hold number of processes in dimensions.</li>
<li><code>pcoord</code> will hold coordinates for each process.</li>
<li><code>main_filed</code> is the local matrix for each process.</li>
</ul>
<p>Let's take a closer look at C source code.</p>
<div class="fragment"><div class="line"><a class="code" href="group__init__final.html#ga3dc660be40c93c169337e3d2692b2ed0">PDI_init</a>(PC_get(conf, <span class="stringliteral">&quot;.pdi&quot;</span>));</div></div><!-- fragment --><p> As mentioned before, we extract the <code>pdi</code> subtree and pass it to PDI_init.</p>
<p>We did not defined <code>mpi_comm</code> data in yaml, so this line will have no effect: </p><div class="fragment"><div class="line"><a class="code" href="group__annotation.html#gabf3f81774644eff9a3cf511e57273454">PDI_expose</a>(<span class="stringliteral">&quot;mpi_comm&quot;</span>, &amp;main_comm, <a class="code" href="group__annotation.html#gga7c857647f7a8077648c28db634eeb805a5cf752cb5cd43b4ae3d7590af61c9939">PDI_INOUT</a>);</div></div><!-- fragment --><p> The same goes for all PDI calls with data we didn't defined.</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> dsize[2];</div><div class="line">PC_int(PC_get(conf, <span class="stringliteral">&quot;.datasize[0]&quot;</span>), &amp;longval); dsize[0] = longval;</div><div class="line">PC_int(PC_get(conf, <span class="stringliteral">&quot;.datasize[1]&quot;</span>), &amp;longval); dsize[1] = longval;</div></div><!-- fragment --><p> Here we are reading global matrix size from specification tree. Similar with parallelism and duration.</p>
<p>After calculating the local matrix sizes and coordinates, we expose them: </p><div class="fragment"><div class="line"><a class="code" href="group__annotation.html#gabf3f81774644eff9a3cf511e57273454">PDI_expose</a>(<span class="stringliteral">&quot;dsize&quot;</span>, dsize, <a class="code" href="group__annotation.html#gga7c857647f7a8077648c28db634eeb805a49ed5399cbc2fca8085867ea04d01b6e">PDI_OUT</a>);</div><div class="line"><a class="code" href="group__annotation.html#gabf3f81774644eff9a3cf511e57273454">PDI_expose</a>(<span class="stringliteral">&quot;psize&quot;</span>, psize, <a class="code" href="group__annotation.html#gga7c857647f7a8077648c28db634eeb805a49ed5399cbc2fca8085867ea04d01b6e">PDI_OUT</a>);</div><div class="line"><a class="code" href="group__annotation.html#gabf3f81774644eff9a3cf511e57273454">PDI_expose</a>(<span class="stringliteral">&quot;pcoord&quot;</span>, pcoord, <a class="code" href="group__annotation.html#gga7c857647f7a8077648c28db634eeb805a49ed5399cbc2fca8085867ea04d01b6e">PDI_OUT</a>);</div></div><!-- fragment --><p>At the beginning of each iteration, we call multiexpose: </p><div class="fragment"><div class="line"><a class="code" href="group__annotation.html#gae5c670b378e423e3083122f62c1f0a59">PDI_multi_expose</a>(<span class="stringliteral">&quot;newiter&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;iter&quot;</span>, &amp;ii, <a class="code" href="group__annotation.html#gga7c857647f7a8077648c28db634eeb805a5cf752cb5cd43b4ae3d7590af61c9939">PDI_INOUT</a>,</div><div class="line">                <span class="stringliteral">&quot;main_field&quot;</span>, cur, <a class="code" href="group__annotation.html#gga7c857647f7a8077648c28db634eeb805a5cf752cb5cd43b4ae3d7590af61c9939">PDI_INOUT</a>,</div><div class="line">                NULL);</div></div><!-- fragment --><p> Above instruction will share <code>iter</code> and <code>main_field</code>, call <code>newiter</code> event and then reclaim <code>main_field</code> and <code>iter</code>. This is the place when plugins will read/write our data.</p>
<p>We have covered the logic behind the PDI example. Now you can start the <a class="el" href="Hands_on.html">Hands-on tutorial</a>. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
</body>
</html>
